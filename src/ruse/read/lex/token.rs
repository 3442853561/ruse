//! A single lexical item.

/// The different types of Token. Some token kinds require additional data,
/// and will carry it here.
#[derive(Debug, PartialEq)]
pub enum TokenKind {
    /// A single open parenthese.
    OpenParen,
    /// A single closed parenthese.
    CloseParen,
    /// An identifier.
    Ident(String),
    /// An integer literal.
    Integer(i64),
    /// A floating point literal.
    Float(f64),
    /// A string
    Str(String),
    /// A boolean
    Bool(bool),
}

/// The location of a token in an input stream.
#[derive(Debug, PartialEq, Clone, Copy)]
pub struct Location(pub usize);

impl Location {
    /// Get the length of the span from the current location to the end
    /// location.
    pub fn to(&self, end_location: Location) -> Span {
        Span(end_location.0 - self.0 + 1)
    }
}

/// The span of a token in an input stream.
#[derive(Debug, PartialEq)]
pub struct Span(pub usize);

/// Tokens, generated by the lexer. Every token has a location in the input
/// stream, a span indicating how large they are, and a type that potentially
/// has some associated data.
#[derive(Debug, PartialEq)]
pub struct Token {
    /// The kind of token, potentially with some additional data.
    pub kind: TokenKind,
    /// The location of the token in the input stream.
    pub location: Location,
    /// The width of the token in the input stream.
    pub span: Span,
}

impl Token {
    /// Token constructor for open parentheses.
    pub fn open_paren(location: Location) -> Token {
        Token {
            kind: TokenKind::OpenParen,
            location: location,
            span: Span(1),
        }
    }

    /// Token constructor for closed parentheses.
    pub fn close_paren(location: Location) -> Token {
        Token {
            kind: TokenKind::CloseParen,
            location: location,
            span: Span(1),
        }
    }

    /// Token constructor for identifiers.
    pub fn ident<S: Into<String>>(name: S, location: Location) -> Token {
        let name: String = name.into();
        let len = name.len();

        Token {
            kind: TokenKind::Ident(name),
            location: location,
            span: Span(len),
        }
    }

    /// Token constructor for strings.
    pub fn string<S: Into<String>>(text: S, location: Location) -> Token {
        let name: String = name.into();
        let len = name.len();

        Token {
            kind: TokenKind::Str(name),
            location: location,
            span: Span(len),
        }
    }

    /// Token constructor for integers.
    pub fn integer(value: i64, start_location: Location, end_location: Location) -> Token {
        Token {
            kind: TokenKind::Integer(value),
            location: start_location,
            span: start_location.to(end_location),
        }
    }

    /// Token constructor for floats.
    pub fn float(value: f64, start_location: Location, end_location: Location) -> Token {
        Token {
            kind: TokenKind::Float(value),
            location: start_location,
            span: start_location.to(end_location),
        }
    }

    /// Token constructor for bools.
    ///
    /// The span is always 2, because true is always `#t` and false is always `#f`.
    pub fn bool(value: bool, start_location: Location) -> Token {
        Token {
            kind: TokenKind::Bool(value),
            location: start_location,
            span: 2,
        }
    }
}
