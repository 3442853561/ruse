//! A single lexical item.

/// The different types of Token. Some token kinds require additional data,
/// and will carry it here.
#[derive(Debug, PartialEq)]
pub enum TokenKind {
    /// A single open parenthese.
    OpenParen,
    /// A single closed parenthese.
    CloseParen,
    /// An identifier.
    Ident(String),
    /// An integer literal.
    IntegerLiteral(i64),
    /// A floating point literal.
    FloatLiteral(f64),
}

/// Tokens, generated by the lexer. Every token has a location in the input
/// stream, a span indicating how large they are, and a type that potentially
/// has some associated data.
#[derive(Debug, PartialEq)]
pub struct Token {
    /// The kind of token, potentially with some additional data.
    pub kind: TokenKind,
    /// The location of the token in the input stream.
    pub location: usize,
    /// The width of the token in the input stream.
    pub span: usize,
}

impl Token {
    /// Token constructor for open parentheses.
    pub fn open_paren(location: usize) -> Token {
        Token {
            kind: TokenKind::OpenParen,
            location: location,
            span: 1,
        }
    }

    /// Token constructor for closed parentheses.
    pub fn close_paren(location: usize) -> Token {
        Token {
            kind: TokenKind::CloseParen,
            location: location,
            span: 1,
        }
    }

    /// Token constructor for identifiers.
    pub fn ident(name: String, location: usize) -> Token {
        let len = name.len();
        Token {
            kind: TokenKind::Ident(name),
            location: location,
            span: len,
        }
    }

    /// Token constructor for integers.
    pub fn integer(value: i64, span: usize, location: usize) -> Token {
        Token {
            kind: TokenKind::IntegerLiteral(value),
            location: location,
            span: span,
        }
    }

    /// Token constructor for floats.
    pub fn float(value: f64, span: usize, location: usize) -> Token {
        Token {
            kind: TokenKind::FloatLiteral(value),
            location: location,
            span: span,
        }
    }
}
