//! The type generated by the parser. It can then be evaluated by the
//! evaluator.

use std::fs::File;
use parse::env::Env;

/// A Rust expression.
pub struct Expr {
    /// The kind of Ruse expression.
    pub kind: ExprKind,
    /// Whether it has been marked by the garbage collector (not yet used)
    pub marked: bool,
    /// Whether it represents mutable data.
    pub mutable: bool,
}

impl Expr {
    /// Get a new expression
    pub fn new(kind: ExprKind) -> Expr {
        let marked = false;
        let mutable = false;

        Expr { kind, marked, mutable }
    }
}

/// The kind of a Ruse expression.
pub enum ExprKind {
    /// A bool
    Bool(bool),
    /// A char
    Char(char),
    /// A number
    Num(Number),
    /// A pair
    Pair(Pair),
    /// A closure
    Closure(Closure),
    /// A syntax object
    Syntax(Syntax),
    /// A symbol object
    Symbol(Symbol),
    /// A string
    Str(String),
    /// A vector
    Vector(Vector),
    /// A bytevector
    ByteVector(ByteVector),
    /// A continuation
    Continuation(Continuation),
    /// A port
    Port(Port),
    /// An environment
    Env(Env),
}

/// Ruse's number type.
#[derive(Debug, PartialEq)]
pub struct Number {
    /// Whether the number is an exact number.
    pub exact: bool,
    /// The kind of number.
    pub kind: NumberKind,
}

/// The kind of a Ruse number.
#[derive(Debug, PartialEq)]
pub enum NumberKind {
    /// A 64-bit integer
    Int(i64),
    /// A 64-bit double
    Real(f64),
    /// A rational fraction
    Rational {
        /// The numerator of the fraction
        numerator: i64,
        /// The denominator of the fraction
        denominator: i64,
    }
}

/// A Ruse pair
pub struct Pair {
    /// The first item of the pair
    pub car: Box<Expr>,
    /// The second item of the pair
    pub cdr: Box<Expr>,
}

/// A Ruse closure
pub struct Closure {
    /// The function to be run
    pub lambda: Box<Lambda>,
    /// The environment to run it in
    pub env: Env,
    /// Whether the closure is a syntactic closure
    pub syntactic: bool,
    /// The body of the function
    pub body: Box<Expr>,
    /// The arguments to the function
    pub args: Box<Expr>,
}

/// A Ruse lambda
pub type Lambda = Fn(Box<Expr>, Box<Env>) -> Box<Expr>;

/// A Ruse syntax object
pub struct Syntax {
    /// The syntax transformer to use
    pub transformer: Box<Expr>,
    /// The environment to use when transforming
    pub env: Box<Env>,
}

/// A Ruse symbol
pub type Symbol = String;

/// A Ruse vector
pub type Vector = Vec<Box<Expr>>;

/// A Ruse byte vector
pub type ByteVector = Vec<u8>;

// TODO: Implement continuations.
/// A Ruse continuation
#[derive(Debug, PartialEq)]
pub struct Continuation {}

/// A Ruse port
#[derive(Debug)]
pub struct Port {
    /// The file the port points to
    pub file: File,
    /// The string to port points to
    pub string: String,
    /// The kind of port it is
    pub kind: PortKind,
    /// Whether the port is writable
    pub writable: bool,
    /// Whether the port is readable
    pub readable: bool,
}

/// The kind of a Ruse port
#[derive(Debug, PartialEq, Eq)]
pub enum PortKind {
    /// The port is textual
    Textual,
    /// The port is binary
    Binary,
}

